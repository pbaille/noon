* Noon experiments

#+begin_src clojure
(ns noon.doc.examples
  (:use noon.score)
  (:require [noon.lib.melody :as m]
            [noon.lib.harmony :as h]
            [noon.lib.rythmn :as r]
            [noon.harmony :as nh]
            [noon.utils.multi-val :as mv]
            [noon.utils.misc :as u]
            [noon.utils.pseudo-random :as pr]
            [noon.constants :as nc]
            [noon.midi :as midi]
            [noon.vst.vsl :as vsl :refer [vsl]]
            [clojure.math.combinatorics :as comb]))
#+end_src

Let's use the chorium soundfont:

#+begin_src clojure :pp
(swap! options* assoc :tracks {0 :chorium})
#+end_src

** Harmonic experiments

Some experiences built on top of an harmonic idea.

*** simple I IV VII I

#+begin_src clojure
(play (scale :harmonic-minor)
      (lin I IV VII I)
      (h/align-contexts :s)
      (each (tup s0 s1 s2)))
#+end_src

Experimenting passing notes:

#+begin_src clojure
(play (scale :harmonic-minor)
      (lin I IV VII I)
      (h/align-contexts :s)
      (lin s0 s1 s2-)
      (each [(tup s0 s2)
             (each (tup s0 c1- s+ s0))])
      (append rev))
#+end_src

#+begin_src clojure
(play dur2
      (scale :harmonic-minor)
      (lin I IV VII I)
      (h/align-contexts :s)

      (lin same (transpose c3) same)

      (chans

       [(patch :choir-aahs) vel4
        (each [(par s0 s1 s2)
               (maybe (tup s0 s1-) (tup s0 s1))])]

       [(patch :ocarina) vel6
        (each [(shuftup s0 s1 s2)
               (each (one-of (tup s0 (shuflin (one-of c1- s-) s+) s0)
                             (tup s0 c1- s0 (one-of s2- s2))))])]

       [(patch :kalimba) vel4 o2
        (each [(shuftup s0 s1 s2)
               (each (one-of vel0 (par s0 s2-) (shuftup s0 s1 s2)))])]

       [(patch :acoustic-bass) vel3
        o2-]))
#+end_src

*** simple I IV I V

#+begin_src clojure :pp
(play dur2
      ;; grid
      (lin I IV I V)
      (h/align-contexts :s)
      ;; on each chord
      (each (chans
          ;; rythmn
          [(patch :woodblock) C0 (dupt 4)]
          [(patch :tinkle-bell) C0 (r/gen-tup 12 5 {:durations [1 2 3]})]
          ;; comping
          [(patch :marimba) o1- (r/gen-tup 12 5 :euclidean) (each (par s0 s2)) (each (one-of s0 s1 s1-))]
          [(patch :acoustic-bass) t2- vel10 (r/gen-tup 12 5 :euclidean :shifted)]
          ;; ornementation
          [vel12 (patch :music-box) o1
           (one-of s0 s1 s1-)
           (shuftup s0 s1 s3)
           (each (probs {[(par s0 s2) (maybe (tup s0 s1))] 3
                      [(tup s3 s1 (par s2 s0) s1-)] 2
                      [(tup d1- s0 d1 s0) (maybe (m/rotation 2))] 1}))]))
      ;; repeat one time
      (dup 2))
#+end_src

*** epic lydian

#+begin_src clojure
(play {:description "epic lydian sequence by minor thirds"}

      (h/harmonic-zip
       [lydian sus47
        (tup* (map root [:C :Eb :F# :A]))
        (dupt 2)
        (h/align-contexts :s)]

       (par [(chan 1) (patch :choir-aahs) vel3
             (ntup 8 (par s0 s1 s2))]

            [vel4
             (let [s? (one-of s2- s1- s1 s2)]
               (m/simple-tupline (* 16 16)
                                 (any-that (within-pitch-bounds? :C-1 :C2)
                                           (lin s? s?)
                                           [(shuflin s1 s2 s3 s4) (maybe rev)]
                                           (lin d1 d1- s0 s?)
                                           (lin d1- d1 s0 s?))))

             (par [(chan 2) (patch :french-horn)]
                  [(chan 3) vel5 o2 (patch :flute)])]

            [(chan 4) (patch :taiko-drum)
             vel2 (ntup 16 (lin dur3 [o1 vel4 dur2] dur3))]

            [(chan 5) (patch :acoustic-bass)
             o2- (ntup 32 t0)]))

      #_(sub {:channel 5} (each tonic-round))

      (adjust 32)
      (nlin 4 (s-shift -1)))
#+end_src

*** Tritonal experiment

A rich harmonic sequence using V I progressions over tritonal modulation cycle (like Giant step).

#+begin_src clojure :pp
(play {:description "tritonal chord sequence shifts by minor thirds"}

      (let [I (one-of [lydian+ (structure [2 3 4 5 6])] [melodic-minor (structure [1 2 4 5 6])])
            V (one-of [V mixolydian (structure [1 3 4 5 6])] [V phrygian6 (structure [0 1 3 5 6])])
            [B G Eb] (map root [:B :G :Eb])]

        [(tup [B V] [B I] [G V] [G I] [Eb V dur2] [Eb I dur2])
         (rup 4 (transpose d2-))
         (h/align-contexts :s :static)

         (chans

          [(patch :choir-aahs)
           vel3
           (each (par s0 s1 s2 s3 s4))]

          [(patch :vibraphone)
           vel5
           (each (probs {(par s0 s1 s2 s3 s4) 1
                      (shuftup [dur2 (par s0 s2 s4)] [(one-of dur2 dur3) (par s1- s1 s3)]) 3}))]

          [(patch :acoustic-bass)
           vel5
           (each [tetrad o2- t0 (maybe (tup (one-of dur2 dur3) [dur2 o1-]))])]

          [(patch :taiko-drum)
           vel3
           (each (shuftup s0 s1 s2 s3 s4))
           (each (probs {vel0 3 same 1 (one-of o1 o1-) 1 (tup t0 t1) 1}))]

          [vel6
           (h/grid-zipped
            [(chans (patch :flute) [o1 (patch :piccolo)])
             (ntup> (* 32 10)
                    (any-that (within-pitch-bounds? :C-2 :C2)
                              s1 s2 s1- s2- s3 s3-))]
            (each (probs {vel0 1
                       same 4
                       (superpose (one-of s1 s2 s3)) 0})))])

         (adjust 48)]))
#+end_src

*** Elliot smith chords

#+begin_src clojure
(play dur2
      (lin [VI seventh]
           [IV add2]
           [I]
           [III seventh (inversion 2)]
           [VI seventh]
           [IV add2]
           (tup I [III seventh phrygian3])
           [IV])
      (h/align-contexts :d)
      (each (chans [(patch :acoustic-bass) o1- t-round]
                   h/simple-chord)))
#+end_src


#+begin_src clojure
(play (chans [(patch :electric-piano-1) (tup (shuftup s0 s1 s2 s3) (shuftup s2 s3 s4 s5))]
             [(patch :acoustic-bass) o1- t-round])
      (dupt 8)
      (h/grid
       [(tup [VI seventh]
             [IV add2]
             [I]
             [III seventh (inversion 2)]
             [VI seventh]
             [IV add2]
             (tup I [III seventh phrygian3])
             [IV])
        (h/align-contexts :d)])
      (adjust 8)
      (dup 2))
#+end_src

*** Minor progression

#+begin_src clojure
(play (lin [I melodic-minor] [V phrygian3] [V phrygian3] [I melodic-minor]
           [I phrygian3] [IV dorian] [II locrian] [IIb lydianb7])
      (dup 2)
      (lin {:section :a}
           [{:section :b} (transpose c6)])
      (h/align-contexts :d)
      (parts {:section :a} (each (chans [(patch :vibraphone) (shuftup s0 s1 s2 s3 s4 s5)]
                                        [(patch :flute) o1 (shuftup s0 s1 s2 s3 s4 s5)]
                                        [(patch :acoustic-bass) o1- t-round]))
             {:section :b} (each (chans [(patch :choir-aahs) vel4 (par s0 s1 s2)]
                                        [(patch :ocarina) vel4 s2- (shuftup s0 s2 s4)]
                                        [(patch :music-box) vel6 o1 (shuftup s0 s1 s2 s3 s4 s5 s6 s7 s8)]
                                        [(patch :acoustic-bass) o1- t-round])))
      (dup 2))
#+end_src

*** I V
A chord sequence based on I V progressions in major and minor.

#+begin_src clojure
(play dur3

      ;; base I V in minor using melodic minor and superlocrian modes
      (lin [I (scale :melm) (structure :tetrad)]
           [V (scale :alt) (structure :sus47)])

      ;; repeat it one time shifting one structural degree down
      (append s1-)

      ;; repeat this 4 bars sequence modulating it a major third up
      ;; degree I becomes lydian and V mixolydianb2
      (append [(transpose c4-)
               (parts (scale :melm) (scale :lydian)
                      (scale :alt) [(scale :mixolydianb2) (structure [1 5 9 10])])])

      ;; the whole sequence is repeated 2 times
      (dup 2)

      ;; align all harmonic contexts so the melody can come over without skips between chords
      (h/align-contexts :s)

      ;; on each chord we apply some content
      ;; melody is built using several techniques
      ;; - passing notes
      ;; - randomized diatonic steps
      (let [below (one-of d1- s1-)
            above (one-of d1 s1)
            contours [[0 -1 1 0]
                      [0 1 -1 0]
                      [-1 0 1 0]
                      [1 0 -1 0]
                      [1 0 -1 0]
                      [-1 0 1 0]]
            passings (mapv (partial mapv {0 _ -1 below 1 above}) contours)
            rand-passing (one-of* (map tup* passings))
            below-step (one-of d1- d3- d4-)
            above-step (one-of d1 d3 d4)
            rand-line (rup 4 (one-of below-step above-step))
            rand-vel (fn [min max] {:velocity (fn [_] (+ min (rand-int (- max min))))})]


        (each (chans
               ;; simple choir structural chords
               [(patch :choir-aahs) vel4 (par s0 s1 s2 s3)
                (h/drop 1)]
               ;; simple bass
               [(patch :acoustic-bass) t-round o1-]
               ;; melody, composing a line using shuftup rand-passing and rand-line
               ;; playing it a the vibraphone
               ;; add some flute and glockenspeil decorations
               [(shuftup s0 s1 s2 s3)
                (each (one-of rand-passing rand-line))
                (chans [(patch :vibraphone) (each (rand-vel 40 70)) (each (maybe vel0))]
                       [(patch :flute)
                        (each (rand-vel 60 80))
                        o1
                        (each (maybe vel0 [(chan inc) (patch :glockenspiel) vel4]))])]))))
#+end_src


*** Not too happy birthday

A simple experiment on happy birthday chords turned into minor.

#+begin_src clojure
(play

  ;; setting up the main scale
  harmonic-minor

  ;; the chord sequence
  (lin I
       V
       VII
       I
       ;; this notation for the secondary dominant of fourth degree
       ;; is not satisfaying, I would like to be able to write `(Vof IV)` maybe...
       [IV melodic-minor VII]
       IV
       I
       VII)

  ;; aligning harmonic contexts to get voice leading more easily
  (h/align-contexts :s)

  ;; simple chord plus arpegio on each chord.
  (each (par (par s0 s1 s2)
             [o1 (shuftup s0 s1 s2)]))

  ;; loop 4 times
  (dup 4))
#+end_src

*** I.m.M7 VI.alt bVI.7.#11 bII.7.sus4

A very artificial sounding chord sequence using quartal voicings and ninuplets (tup of size 9)

#+begin_src clojure
(play (lin [I melodic-minor] [VI superlocrian] [VIb lydianb7] [IIb mixolydian])
      (h/align-contexts :s)
      (dup 2)
      (each (chans [(patch :vibraphone) vel6 t0 (par> d0 d3 d3 d3 d3)]
                   [(patch :acoustic-bass) vel6 t2-]
                   [(patch :taiko-drum) (shuftup vel3 vel5 [vel4 (dupt 2)])]
                   [(ntup> 9 (any-that (within-pitch-bounds? :G-1 :C2)
                                       d1- d1 d3 d3- d4 d4-))
                    vel9
                    (chans (patch :flute)
                           [o1- vel4 (patch :vibraphone)])]))
      (lin _ c6)
      (dup 2) )
#+end_src


** Melodic experiments

*** Target notes
Building good rythmic melodies is not easy.
Here, I will try to start from target notes and fill the holes between them.

#+begin_src clojure
(play eolian
      (lin s0 s2 s1 s0))
#+end_src

How to fill between the notes of this simple line?

#+begin_src clojure
(def fill-diatonically
  "A very low level way to connect subsequent notes diatonically using `noon.harmony` directly.
   It feels too complicated for such a simple thing..."
  (sf_ (let [sorted (sort-by :position _)
             couples (partition 2 1 sorted)]
         (-> (reduce (fn [ret [a b]]
                       (let [va (pitch-value a)
                             vb (pitch-value b)
                             direction (if (> va vb) :down :up)
                             cnt (loop [cnt 0 current (:pitch a)]
                                   (case direction
                                     :up (if (>= (nh/hc->chromatic-value current) vb)
                                           cnt
                                           (recur (inc cnt) (nh/upd current (nh/d-step 1))))
                                     :down (if (<= (nh/hc->chromatic-value current) vb)
                                             cnt
                                             (recur (inc cnt) (nh/upd current (nh/d-step -1))))))]
                         (concat-score ret
                                       (update-score #{(assoc a :position 0)}
                                                     (rup cnt (case direction :up d1 :down d1-))))))
                     #{}
                     couples)
             (conj (last sorted))))))

;; trying it on a basic structural line
(play eolian
      (lin s0 s2 s1 s0)
      fill-diatonically)
#+end_src

Let's generalise to other layers:

#+begin_src clojure
(defn fill-line
  "This evolution of fill-diatonically let the user specify the harmonic layer.
   It is still relying on `noon.harmony` which is not great."
  [layer]
  (sf_ (let [sorted (sort-by :position _)
             couples (partition 2 1 sorted)]
         (-> (reduce (fn [ret [a b]]
                       (let [va (pitch-value a)
                             vb (pitch-value b)
                             direction (if (> va vb) :down :up)
                             [check increment] (case direction :up [>= 1] :down [<= -1])
                             cnt (loop [cnt 0 current (:pitch a)]
                                   (if (check (nh/hc->chromatic-value current) vb)
                                     cnt
                                     (recur (inc cnt) (nh/upd current (nh/layer-step layer increment)))))]
                         (concat-score ret
                                       (update-score #{(assoc a :position 0)}
                                                     (rup cnt (ef_ (update _ :pitch (nh/layer-step layer increment))))))))
                     #{}
                     couples)
             (conj (last sorted))))))

;; The same as in previous example
(play eolian
      (lin s0 s2 s1 s0)
      (fill-line :c))

;; A more elaborated example using structural filling
(play dur:2
      harmonic-minor
      tetrad
      (patch :orchestral-harp)
      (lin s0 s2 s2- s4 s4- s2 s2- s5-)
      (lin _ [(transpose c6) s2 rev])
      (lin _ s2 s2-)
      (fill-line :s))
#+end_src

Next step will be to have control over the number of notes between targets.

#+begin_src clojure
(defn target
  [layer size direction duration]
  (sfn score
    (->> score
         (map (fn [e]
                (->> (range size)
                     (map (fn [i]
                            (-> (update e :pitch
                                        (nh/layer-step
                                         layer
                                         (case direction
                                           :up (inc i)
                                           :down (- (inc i)))))
                                (update :position - (* (inc i) duration))
                                (assoc :duration duration))))
                     (into #{e}))))
         (merge-scores))))

;; It is a step in the right direction but it overlaps passing notes
(play (lin _
           [s2 (target :c 3 :up 1/4)]
           [s1- (target :d 3 :down 1/4)]
           [_ (target :c 3 :up 1/4)])
      (options {:filename "test/trash/target"}))
#+end_src

The problem here is that the precedent note overlaps the targeting notes.

#+begin_src clojure
(defn connect [& sizes]
  (sf_ (let [sorted (sort-by :position _)]
         (reduce (fn [s [n1 n2]]
                   (let [hcs (loop [sizes sizes]
                               (if-let [[s & sizes] (seq sizes)]
                                 (or (nh/simplest-connection s (:pitch n1) (:pitch n2))
                                     (recur sizes))))
                         duration (/ (:duration n1) (dec (count hcs)))]

                     (into s (map-indexed (fn [idx pitch]
                                            (assoc n1
                                                   :pitch pitch
                                                   :position (+ (* idx duration) (:position n1))
                                                   :duration duration))
                                          (butlast hcs)))))
                 #{(last sorted)} (partition 2 1 sorted)))))

(play harmonic-minor
      (lin I [VI lydianb7] V IV [II phrygian3] [V eolian] [IIb lydian])
      (h/align-contexts :s)
      (m/$lin [(lin s0 s2 s2- s4) (maybe [rev s2])])
      (lin _ s1 s1- _)
      (chans [(patch :tango) (connect 5 3 2 1 0)]
             [(patch :ocarina) vel6 s2 (connect 2 1 0)]
             [(patch :acoustic-bass) o1- s2- (connect 1 0)]))
#+end_src


The =connect= function is now available in =noon.lib.melody=

#+begin_src clojure
(play harmonic-minor
      (lin I [VI lydianb7] V IV [II phrygian3] [V eolian] [IIb lydian])
      (h/align-contexts :s)
      (m/$lin [(lin s0 s2 s2- s4) (maybe [rev s2])])
      (lin _ s1 s1- _)
      (chans [(patch :tango) (m/connect 5 3 2 1 0)]
             [(patch :ocarina) vel6 s2 (m/connect 2 1 0)]
             [(patch :acoustic-bass) o1- s2- (m/connect 1 0)]))
#+end_src

*** Passing notes
**** experience 1

#+begin_src clojure
;; Try to implement diverse melodic passing notes things.

;; Mono harmony passing notes

(play (rep 6 s1)
      (m/connect 1))

(play o1
      (rep 6 s1-)
      (m/connect 1))

(= (mk (tup d1- d0))
   (mk (tup d1- d0)
       (m/connect 1)))

(defn connect-with [f]
  (m/$connect (fn [from to]
                (update-score #{(assoc from :position 0)}
                              [(lin _ [(ef_ (assoc _ :pitch (:pitch to)))
                                       f])
                               (adjust from)]))))

(play (lin s0 s2 s4)
      (connect-with d1))

(play (lin s0 s2 s4)
      (lin s0 s1 s2)
      (connect-with (tup d1- d1)))

(play [eolian dur:2]
      (lin s0 s2 s4)
      (lin s0 s1 s2)
      (connect-with (shuflin d1 c1-)))

;; With chord changes

(play harmonic-minor
      (lin I VII)
      (nlin> 3 (transpose c3))
      (h/align-contexts :s)
      (dup 2)
      (each (ntup> 6 s1))
      (connect-with d1))

;; With parts and vsl

(vsl/noon {:play true}
          (mk
           ;; grid
           [harmonic-minor
            (lin I VII)
            (nlin> 3 (transpose c3))
            (h/align-contexts :s)
            (dup 4)]
           ;; parts
           (par
            ;; flute melody
            [(vsl :flute-1 :staccato)
             o1 vel4
             (each (shuftup s0 s2 s4))
             (connect-with (one-of d1- d1))]
            ;; bass
            [(vsl :solo-double-bass :pizzicato)
             o1- t-round]
            ;; viola comping
            [(vsl :chamber-violas :pizzicato)
             vel5
             (each (one-of (tup s1 (par s2 s3) vel0)
                           (tup vel0 s1 (par s2 s3))))])))

;; Targetting other chord/key

(defn connect-with2 [f]
  (m/$connect (fn [from to]
                (let [{:keys [scale structure origin]} (:pitch from)
                      target-pitch (:pitch to)]
                  (update-score #{(assoc from :position 0)}
                                [(lin _ [(ef_ (assoc _ :pitch target-pitch))
                                         (rescale scale)
                                         (restructure structure)
                                         (reorigin origin)
                                         f])
                                 (adjust from)])))))

(play (lin d0 [IIb mixolydian])
      (connect-with d1-))
(play (lin d0 [IIb mixolydian])
      (connect-with2 d-floor))
(play (lin d0 d-floor))

;; This is difficult... to be continued
#+end_src

**** polarity

#+begin_src clojure
;; This morning I was playing modal melodies on the flute, and experimenting with different polarity cycles.

[0 0 1 0]
[0 1 1 0]

;; 0 can represent tonic and 1 dominant, whatever it means depending on the harmonic context.

;; let's take the phrygian mode as an example.

[0 0 1 0 1 0 0 1]

(play phrygian
      (lin I I VII I VII I VII VII)

      (mixlin s0 s2)
      (each (chans [(patch :acoustic-bass) o2- (maybe t-round)]
                   [(patch :ocarina) s2 (shuftup s0 s2 s4)]))
      (lin _ [rev (transpose c3-)])
      (parts (chan 1) (connect-with (one-of (one-of d1 d1-)
                                            (shuflin (one-of s1 s1-) (one-of d1 d1-))))
             (chan 0) (each (probs {(tup (one-of s1 s1-) _) 1
                                    _ 4}))))

;; Let's experiment around creating those polarity sequences

(let [id identity
      rev (fn [x] (mapv {0 1 1 0} x))
      _dup (fn [x] (vec (concat x x)))
      cat (fn [& xs] (fn [x] (vec (mapcat (fn [f] (f x)) xs))))
      acc (fn [n f] (apply comp (repeat n f)))
      each (fn [f] (fn [x] (vec (mapcat (comp f vector) x))))
      _scan (fn [size step f] (fn [x] (vec (mapcat f (partition size step x)))))
      >> (fn [& xs] (fn [x] (reduce #(%2 %1) x xs)))
      upd (fn [x f] (f x))]
  (upd [1]
       (>> (acc 3 (cat id rev))
           (each (cat id rev id)))))

;; to be continued...
#+end_src

**** degree moves

#+begin_src clojure
;; It seems that the degree that is under the current one can serve as kind of a dominant.

(play dorian
      (nlin> 8 s1)
      [(patch :ocarina) (connect-with (degree -1))])

(play dorian
      dur4 o1 (lin _ (nlin> 3 s1-))
      [(patch :ocarina) (connect-with (degree 1))]
      (each (tup s0 s2))
      (connect-with (degree 1)))

(let [pol+ {:polarity 0}
      pol- {:polarity 1}
      invert-pol (each {:polarity (fn [x] (case x 0 1 1 0))})]
  (play lydianb7
        dur2
        (lin pol+ pol-)
        (lin _ invert-pol)
        (tup _ invert-pol)
        (rep 4 (transpose c3-))
        (h/align-contexts :s)
        (dup 2)
        (parts pol+ _
               pol- (each (one-of (degree -1) (degree 1))))
        (chans [(patch :ocarina) (each [(one-of s0 s1) (shuftup s0 s1 s2 s3)]) (connect-with (one-of d1 d1-))]
               [(patch :acoustic-bass) o1- (each (one-of s0 s1- s2-))])))

(let [pol+ {:polarity 0}
      pol- {:polarity 1}
      invert-pol (each {:polarity (fn [x] (case x 0 1 1 0))})]
  (play (chans [(patch :ocarina)
                s2- (ntup> 7 s1)
                (shuftup [_ (connect-with d1)]
                         [rev s1- (connect-with d1-)])
                (dupt 16)]
               [(patch :acoustic-bass) (dupt 64) o2- t-round (each (maybe s2- s2))])
        (h/grid [phrygian3
                 (tup pol+ pol-)
                 (tup _ invert-pol)
                 (tup _ invert-pol)
                 (rup 4 (transpose c3-))
                 (h/align-contexts :s)
                 (dupt 2)
                 (parts pol+ _
                        pol- (each (degree -1)))])
        (adjust {:duration 64})))
#+end_src

*** Canon
First thing would be to come up with a simple melodic motiv.
It will be based on a triad, with some decorating tones.

The skeleton could be something like

#+begin_src clojure
(play (shuftup s0 s1 s2))
#+end_src

We can start in 3/4.
The next step will be to decorate it.

Previously we've discussed the connect function that can do something like this

#+begin_src clojure
(play (shuftup s0 s1 s2)
      (m/connect 1))
#+end_src

But it is not really what we want.


#+begin_src clojure
(def decorate
  (sf_ (let [sorted (sort-by :position _)]
         (reduce (fn [s [n1 n2]]
                   (into s (update-score #{n1 n2} (maybe (m/connect 1)))))
                 #{(last sorted)} (partition 2 1 sorted)))))

(noon {:play true :pdf true}
      (mk dur2
          (lin (shuftup s0 s1 s2 s3)
               [(one-of s1 s1-) (shuftup s0 s1 s2 s3)])
          decorate
          (lin _ (s-shift 1) (s-shift -1) _)
          (lin _ (s-shift 2))
          (chans [(patch :ocarina) o1 (s-shift -1)]
                 [(sf_ (shift-score _ 2))]
                 [(patch :acoustic-bass) o2- (s-shift 1) (sf_ (shift-score _ 5))])
          (h/grid dur2
                  harmonic-minor
                  (lin I IV VII I [IV melodic-minor VII] IV [V harmonic-minor VII] VII)
                  (dup 4)
                  (h/align-contexts :s))))
#+end_src


** Concepts and techniques

Some attempts to implement or illustrate various musical ideas using noon.

*** Barry Harris

#+begin_src clojure
(def barry-harris (scale [0 2 4 5 7 8 9 11]))
#+end_src


#+begin_src clojure
(play barry-harris
      (tup d0 d3 d4 d7)
      (tup d0 d2)
      (rep 4 d1))
#+end_src


#+begin_src clojure
(let [chord-tones [d0 d2 d4 d7]]
  (play barry-harris
        (lin d0 d3)
        (rep 8 (one-of d1- d1))
        (each [(chans [(patch :pad-1-new-age) o1- vel3 (par* chord-tones)]
                      [(patch :ocarina) vel4 (shuftup* chord-tones) (each (maybe (tup (one-of d1 d1-) d0)))]
                      [(patch :vibraphone) vel5 o1 (ntup 6 [(one-of* chord-tones) (maybe o1) (maybe (tup d1- d0))])])
               (maybe rev)])))
#+end_src


#+begin_src clojure
(def barry-harris2 [barry-harris (structure [0 2 4 7])])
#+end_src


#+begin_src clojure
(play barry-harris2
      (lin I VI VII IV)
      (h/align-contexts :d)
      (each (chans [(patch :brass) (par s0 s1 s2 s3)]
                   [(patch :acoustic-bass) o1- t-round]
                   [(patch :ethnic) o1 (shuftup s0 s1 s2 s3 s4 s5 s6)]))
      (rep 2 s1)
      (append (transpose c3)))
#+end_src


#+begin_src clojure
(play barry-harris2
      (lin IV I)
      (h/align-contexts :d)
      (each (par s0 s1 s2 s3))
      (rep 4 (transpose c3))
      h/voice-led)
#+end_src

*** Symetric modes

#+begin_src clojure
(def symetric-modes {:half-whole (scale [0 1 3 4 6 7 9 10])
                     :whole-half (scale [0 2 3 5 6 8 9 11])
                     :whole (scale [0 2 4 6 8 10])
                     :augm-half (scale [0 3 4 7 8 11])
                     :half-augm (scale [0 1 4 5 8 9])
                     :messian3 (scale [0 2 3 4 6 7 8 10 11])
                     :messian4 (scale [0 1 2 5 6 7 8 11])
                     :messian5 (scale [0 1 5 6 7 11])
                     :messian6 (scale [0 2 4 5 6 8 10 11])
                     :messian7 (scale [0 1 2 3 5 6 7 8 9 11])})
#+end_src


#+begin_src clojure
(play (symetric-modes :augm-half)
      (:two {:one (rup 8 (one-of d1 d1- d2 d2- d3 d3-))
             :two (shuftup d1 d2 d3 d4 d5 d6 d7)})

      (patch :electric-piano-1)
      (rep 32 (one-of (each d3)
                      (each d3-)
                      (m/rotation 1/2)
                      (m/permutation :rand {:grade 2})
                      (m/contour :similar {:delta 0 :layer :d}))))
#+end_src


#+begin_src clojure
(defn rand-structure [size]
  (ef_ (let [degree-count (-> _ :pitch :scale count)
             degrees (first (mv/consume size (mv/mix* (range degree-count))))]
         (update-score #{_} (structure (vec (sort degrees)))))))
#+end_src


#+begin_src clojure
(def rand-degree
  (ef_ (let [scale-size (-> _ :pitch :scale count)
             deg (rand-nth (range 1 scale-size))]
         (update-score #{_} (degree (rand-nth [(- deg) deg]))))))
#+end_src


#+begin_src clojure
(defn rand-tup [size]
  (ef_ (let [degree-count (-> _ :pitch :scale count)
             degrees (first (mv/consume size (mv/mix* (range degree-count))))]
         (update-score #{_} (tup* (mapv d-step degrees))))))
#+end_src


#+begin_src clojure
(play (symetric-modes :half-whole)
      (rand-structure 3)
      (rep 3 rand-degree)
      (each (chans [vel4 h/simple-chord]
                   [(patch :music-box) o1 (rand-tup 7) (each (one-of vel0 vel4 vel6 vel7))]))
      (append [rev s2])
      (append (transpose c5))
      (append (between 0 1/3)))
#+end_src

*** Arvo Part

#+begin_src clojure
(let [m-line (fn [size]
               (pr/rand-nth (vals {:up-to [(rep size d1-) rev]
                                   :up-from (rep size d1)
                                   :down-to [(rep size d1) rev]
                                   :down-from (rep size d1-)})))
      base (pr/shuffle (map vector
                            [s0 s1 s2 (one-of s0 s1 s2)]
                            (map m-line (pr/shuffle (pr/rand-nth (u/sums 12 4 [2 3 4 5]))))))]
  (play lydianb7
        (lin* base)
        (each (chans [(patch :piccolo) vel6 o1]
                     [(patch :flute) vel3 o1 d5-]
                     [(patch :accordion) vel4 d0]
                     [(patch :choir-aahs) s-floor (vel-humanize 7 [40 80])]
                     [(patch :choir-aahs) s-floor o1 s1 (vel-humanize 7 [40 80])]
                     [(patch :acoustic-bass) C-2 t-floor]))

        m/connect-repetitions
        (append [rev (transpose c3-)])
        (append dorian)
        (dup 2)))

#+end_src

*** Bartok harmony axis

#+begin_src clojure
(let [L- (transpose c5)
      L+ (transpose c5-)
      R- (transpose c3)
      R+ (transpose c3-)
      M (transpose c6)]
  (play (rep 8 [(one-of L- L+) (maybe R- R+ M) (one-of ionian eolian)])
        (h/align-contexts :d)
        (chans [(patch :aahs) (each (par s0 s1 s2))]
               [(patch :ocarina) o1 (each (shuftup s2- s1- s0 s1 s2 s3))]
               [(patch :acoustic-bass) o1-
                t-round
                (maybe s1 s1-)])
        (lin _ s1 s1- _)))
#+end_src


#+begin_src clojure
(let [L- (transpose c5)
      L+ (transpose c5-)
      R- (transpose c3)
      R+ (transpose c3-)
      M (transpose c6)
      tup1 (mixtup s2- s1- s0 s1 s2 s3)
      tup2 (mixtup s2- s1- s0 s1 s2 s3)]
  (play (rep 8 [(one-of L- L+) (maybe R- R+ M) (one-of ionian eolian)
                (maybe dur2 dur:2)])
        (h/align-contexts :d)
        (chans [(patch :aahs)
                (each [add2 (par s0 s1 s2 s3)])
                m/connect-repetitions]
               [(patch :ocarina) o1 add2 (each [(one-of tup1 tup2) (maybe rev)])]
               [(patch :acoustic-bass) o1-
                t-round
                (maybe s1 s1-)])
        (lin _ s1 s1- _)))
#+end_src


#+begin_src clojure
(let [L- (transpose c5)
      _L+ (transpose c5-)
      R- (transpose c3)
      R+ (transpose c3-)
      M (transpose c6)

      base [(pr/rand-nth [R- R+ M]) (pr/rand-nth [ionian eolian])]
      rand-color [(maybe R- R+ M) (one-of ionian eolian)]
      tup1 (mixtup s2- s1- s0 s1 s2 s3)
      tup2 (mixtup s2- s1- s0 s1 s2 s3)]
  (play base
        (lin _ [L- rand-color] rand-color [L- rand-color] _)
        (lin _ M rev)
        (h/align-contexts :d)
        (chans [(patch :aahs)
                (each [add2 (par s0 s1 s2 s3)])
                m/connect-repetitions]
               [(patch :ocarina) o1 add2 (each [(one-of tup1 tup2) (maybe rev)])]
               [(patch :acoustic-bass) o1-
                t-round
                (maybe s1 s1-)])
        (lin _ s1 [rev s1-] _)))
#+end_src


#+begin_src clojure
(let [initial [{:harmonic-coords [0 0]} melodic-minor sixth]
      up [{:harmonic-coords (fn [[x y]] [x (mod (inc y) 3)])} (transpose c5)]
      down [{:harmonic-coords (fn [[x y]] [x (mod (dec y) 3)])} (transpose c5-)]
      left [{:harmonic-coords (fn [[x y]] [(mod (dec x) 4) y])} (transpose c3)]
      right [{:harmonic-coords (fn [[x y]] [(mod (inc x) 4) y])} (transpose c3-)]]
  (play initial
        (lin> _ up left down)
        (lin _ up)
        (lin _ [rev left])
        (lin _ [right right])
        (h/align-contexts :d)
        (chans [(patch :aahs) (structure [1 2 5 6]) (each (par s0 s1 s2 s3))]
               (let [tup1 (mixtup s2- s1- s0 s1 s2 s3)
                     tup2 (mixtup s2- s1- s0 s1 s2 s3)]
                 [(patch :ocarina) o1 add2 (each [(one-of tup1 tup2) (maybe rev)])])
               [(patch :acoustic-bass) o1-
                t-round
                (maybe s1 s1- s2-)])
        (lin _ s1 [up s1-] up)))
#+end_src


#+begin_src clojure
(let [initial [lydian seventh]
      up (transpose c5)
      down (transpose c5-)
      left (transpose c3)
      right (transpose c3-)]
  (play ;; grid
   [initial
    (lin> _ up left down)
    (each (maybe (degree 2) (degree -2)))
    (lin _ up)
    (lin _ [rev left])
    (lin _ [right right])
    (h/align-contexts :d)]
   ;; voices
   (chans [(patch :aahs) (each (par s0 s1 s2 s3))]
          #_[(patch :aahs) t-round (each (par d0 d3 d6 d9)) #_h/voice-led]
          (let [tup1 [(structure [2 3 4 6]) (mixtup s3- s2- s1- s0 s1 s2 s3 s4)]
                tup2 (mixtup d3- d2- d1- d0 d1 d2 d3 d4)]
            [(patch :ocarina) o1 (each [(one-of tup1 tup2) (maybe rev)])])
          [(patch :acoustic-bass) o2-
           t-round
           (each (probs {_ 3
                         (one-of s1- s2) 3
                         (tup _ (one-of s1- s2)) 1
                         (tup (one-of s1- s2) _) 1}))])
   ;; why not ?
   (lin _ s1 [up s1-] up)
   (options :bpm 40 :xml true)))
#+end_src

*** Simple counterpoint

#+begin_src clojure
(let [perms (comb/permutations [0 1 2 3])
      complementary-map
      (reduce (fn [acc p]
                (assoc acc p
                       (filter (fn [p']
                                 (every? (fn [[a b]] (not= (mod a 3) (mod b 3)))
                                         (map vector p p')))
                               perms)))
              {} perms)

      [base complements] (rand-nth (seq complementary-map))
      voice1 (rand-nth complements)
      voice2 (map (fn [a b]
                    (first (filter (complement (set (map #(mod % 3) [a b])))
                                   [0 1 2])))
                  base
                  voice1)]

  (play (patch :electric-piano-1)
        (chans (lin* (map s-step base))
               [o1- (lin* (map s-step voice1))]
               [o1 (lin* (map s-step voice2))])
        [eolian
         (lin _ (degree -1))
         (lin _ s1)
         (lin _ [(degree 3) s1-])
         (lin _ (transpose c3-))]
        ($by :channel (connect-with (probs {void 5 d1 1 d1- 1})))))

;; this complementary util is interesting, but the way I get the third voice is not pretty.
;; How about introducing another level ?

(defn complementarity-tree

  ([structure-size sequence-size]
   (let [elements (range structure-size)
         q (quot sequence-size structure-size)
         r (rem sequence-size structure-size)
         base (apply concat (repeat q elements))
         partials (filter (fn [s] (= r (count s))) (comb/subsets elements))
         permutations (mapcat (fn [p] (comb/permutations (concat base p))) partials)]
     (complementarity-tree [] structure-size (set permutations))))

  ([at structure-size perms]
   (if-let [perms
            (some-> (if (seq at)
                      (filter (fn [p']
                                (every? (fn [xs]
                                          (apply distinct?
                                                 (map #(mod % structure-size) xs)))
                                        (apply map vector p' at)))
                              perms)
                      perms)
                    seq
                    set)]
     (->> perms
          (map (fn [child]
                 [child
                  (complementarity-tree
                   (conj at child)
                   structure-size
                   (disj perms child))]))
          (into {})))))

(defn leaves-paths
  ([m] (leaves-paths m []))
  ([x at]
   (if (and (map? x) (not-empty x))
     (mapcat (fn [[k v]] (leaves-paths v (conj at k))) x)
     [at])))

(let [[v1 v2 v3] (->> (complementarity-tree 3 3)
                      (leaves-paths)
                      (filter #(= 3 (count %)))
                      (rand-nth))]
  (play [dur3
         eolian
         (lin _ (degree -1))
         (lin _ s1)
         (lin _ [(degree 3) s1-])
         (lin _ [s1 (transpose c3-)])]
        (patch :electric-piano-1)
        (each (! (let [[v1 v2 v3] (shuffle [v1 v2 v3])]
                   (chans (tup* (map s-step v1))
                          [o1- (tup* (map s-step v2))]
                          [o1 (tup* (map s-step v3))]))))
        ($by :channel (connect-with (probs {void 5 d1 1 d1- 1})))))

;; could this complementarity-tree be used to for rythmn ?

(let [[[r1 r2 r3] [l1 l2 l3]] (->> (complementarity-tree 3 3)
                                   (leaves-paths)
                                   (filter #(= 3 (count %)))
                                   (shuffle))
      f (fn [r l] (tup* (map (fn [r l]
                              [(s-step l)
                               (case r
                                 0 _
                                 1 (tup [dur2 _] (one-of d1 d1-) _)
                                 2 (one-of (tup _ d1 d1- _)
                                           (tup _ d1- d1 _)))])
                            r l)))]
  (vsl/noon {:play true}
            (mk [dur3
                 eolian
                 (lin _ (degree -1))
                 (lin _ s1)
                 (lin _ [(degree 3) s1-])
                 (lin _ [s1 (transpose c3-)])]
                (each (! (let [[a b c] (shuffle [(f r1 l1) (f r2 l2) (f r3 l3)])]
                           (chans
                                        ;[(vsl :flute-1 :staccato) vel3 o1 (s-shift 1) c]
                            [(vsl :solo-violin-1 :pizzicato) o1 b]
                            [(vsl :solo-viola :pizzicato) c]
                            [(vsl :solo-cello-1 :pizzicato) o1- a])))))))

;; We miss meaninful connections between triad degrees, here we only do ornementation.
;; This is also a bit too monotonic.

(let [[arpegios ornamentations harmonic-sequences]
      (->> (complementarity-tree 3 3)
           (leaves-paths)
           (filter #(= 3 (count %)))
           (shuffle))

      choices {:harmony {0 _
                         1 [(degree 3) (s-shift -1)]
                         2 [(degree 4) (s-shift -2)]}
               :arpegio {0 s0 1 s1 2 s2}
               :ornamentation {0 void
                               1 d1
                               2 d1-}
               :instruments {0 [vel8 (vsl :chamber-violins-1 :legato) o1]
                             1 [vel7 (vsl :chamber-violas :legato)]
                             2 [vel6 (vsl :chamber-cellos :legato) o1-]}}

      degrees (mapcat (fn [s]
                        (map (choices :harmony) s))
                      harmonic-sequences)
      lines (map (fn [offset]
                   [(get-in choices [:instruments offset])
                    (lin* (map (fn [d a c]
                                 [d (tup* (map (fn [step orn]
                                                 [(get-in choices [:arpegio step]) {:connection orn}])
                                               a c))])
                               degrees
                               (drop offset (cycle arpegios))
                               (drop offset (cycle ornamentations))))])
                 (range 3))]
  (vsl/noon {:pdf true
             :play true}
            (mk dur8
                harmonic-minor
                (par* lines)
                (lin _ (transpose c3-))
                ($by :channel (connect-with
                               (sf_ (->> (get-in choices [:ornamentation (:connection (first _))])
                                         (update-score _))))))))

(let [[arpegios ornamentations harmonic-sequences articulations]
      (->> (complementarity-tree 3 3)
           (leaves-paths)
           (filter #(= 3 (count %)))
           (shuffle))

      choices {:harmony {0 _
                         1 [lydian (transpose c4) (s-shift -1)]
                         2 [(transpose c2-)]}
               :arpegio {0 s0 1 s1 2 s2}
               :ornamentation {0 void
                               1 (lin vel0 d1)
                               2 (lin d1- vel0)}
               :instruments {0 [(vsl/instrument :chamber-violins-1) o1]
                             1 [(vsl/instrument :chamber-violas)]
                             2 [(vsl/instrument :chamber-cellos) o1-]}
               :articulations {0 (vsl/patch :pizzicato)
                               1 (vsl/patch :pizzicato)
                               2 (vsl/patch :pizzicato)}}

      degrees (mapcat (fn [s]
                        (map (choices :harmony) s))
                      harmonic-sequences)
      lines (map (fn [offset]
                   [(get-in choices [:instruments offset])
                    (lin* degrees)
                    (each (tup* (map (fn [d a c p]
                                       [d (tup* (map (fn [step orn p]
                                                       [(one-of vel3 vel6 vel9)
                                                        (get-in choices [:articulations p])
                                                        (get-in choices [:arpegio step])
                                                        {:connection orn}])
                                                     a c p))])
                                     degrees
                                     (drop offset (cycle arpegios))
                                     (drop (* 2 offset) (cycle (concat ornamentations arpegios)))
                                     (drop offset (cycle articulations)))))])
                 (range 3))]
  (vsl/noon {:pdf true
             :play true}
            (mk dur8
                dur2
                dorian
                (par* (cons bass lines))
                (lin _ (transpose c3-))
                ($by :channel (connect-with
                               (sf_ (->> (get-in choices [:ornamentation (:connection (first _))])
                                         (update-score _))))))))
#+end_src


** Tunes

Trying to make music on top of some known jazz standards

*** Autumn leaves

Simple experiment on the first part of autumn leaves grid:

#+begin_src clojure :pp
(play {:title "Autumn Leaves"}

      vel3
      [tetrad
       (lin II V I IV VII [III phrygian3] [VI (lin [melodic-minor sixth] phrygian3)])
       (h/align-contexts :s)
       (dup 2)]

      (h/grid-zipped
       (nlin 16 (chans [(patch :acoustic-bass)
                        o1- t-round]

                       [(patch :vibraphone)
                        (par s0 s1 s2 s3)]

                       [(patch :electric-piano-1) vel2
                        o2 (par s0 s2 s4) (shuftup s0 s2)]

                       [(patch :whistle) o1 vel5
                        (each [(shuftup s0 s1 s2 s3)
                               (tup same (one-of s1 s1- s2 s2-))])]))))
#+end_src

*** Giant steps (John Coltrane)

An experiment using Giant steps harmony.

Ocarina runs over simplistic bass and piano comping.

#+begin_src clojure :pp

(def GIANT_STEPS
  (let [II [II {:degree :II}]
        V [V {:degree :V}]
        I [I {:degree :I}]
        t1 same
        t2 (transpose c4-)
        t3 (transpose c4)
        s1 (lin [t1 I] [t2 (lin V I)] [t3 (lin V [dur2 I])] [t2 (lin II V)])
        II-V-I (lin II V [I dur2])]
    [tetrad
     (tup s1
          [t2 s1]
          [t3 I dur2] [t2 II-V-I] II-V-I [t3 II-V-I] [t1 (lin II V)])
     (h/align-contexts :structural :static)]))

(play vel3
      (h/harmonic-zip
       [GIANT_STEPS (dupt 2)]
       (chans
        [(patch :acoustic-bass) o2- (each t-round)]
        [(patch :electric-piano-1) (each (par s0 s1 s2 s3))]
        [(patch :ocarina)
         vel5
         (each (parts {:degree :II} (structure [0 3 4 6])
                   {:degree :V} (structure [1 2 5 6])
                   {:degree :I} (structure :tetrad)))
         (ntup 32 [(one-of o1 o2)
                   (! (rup (pr/rand-nth [5 6 7]) s1))
                   (tup (maybe (m/permutation 1/4))
                        [(maybe rev) (one-of s1 s2 s2- s1-)])])]))
      m/connect-repetitions
      (adjust 32))
#+end_src

*** ESP (Wayne Shorter)

first try:

#+begin_src clojure
(play

  {:title "ESP"
   :composer "Wayne Shorter"}

  (h/harmonic-zip
   ;; grid
   [tetrad
    (tup [VII superlocrian dur2] [I lydian dur2]
         [VII superlocrian dur2] [VIIb lydian dur2]
         [VI superlocrian] [VIIb lydian] [VII superlocrian] (tup [I lydian] [VIIb lydianb7])
         [VI dorian] [II lydianb7] [II dorian] [IIb lydianb7])
    (h/align-contexts :s)
    (dupt 2)]

   ;; parts
   [vel4
    (chans [(patch :acoustic-bass) o2-
            t-round]

           [(patch :electric-piano-1) vel3 o1-
            (par> d0 d3 d3 d3 d3)]

           [(patch :flute) vel6
            (fill> (/ 1 (* 2 32 6)) (any-that (within-pitch-bounds? :C0 :C3) d4- d3- d1- d1 d3 d4))])])

  ;; repeat
  (adjust 32)
  (dup 2))
#+end_src

full grid:

#+begin_src clojure
(def ESP_fullgrid
  (let [common (lin [VII superlocrian dur2] [I lydian dur2]
                    [VII superlocrian dur2] [VIIb lydian dur2]
                    [VI superlocrian] [VIIb lydian] [VII superlocrian] (tup [I lydian] [VIIb lydianb7]))]
    (tup common
         (lin [VI dorian] [II lydianb7] [II dorian] [IIb lydianb7])
         common
         (lin [VIb lydianb7] [II dorian] (tup [VIb dorian] [IIb lydianb7]) I))))

(play
  (h/harmonic-zip
   [ESP_fullgrid
    (dupt 2)
    (h/align-contexts :s)]

   (chans

    [(patch :electric-piano-1) o1- vel3
     (voices> d0 d3 d3 d3 d3)]

    [(patch :acoustic-bass) vel2 C-2 t-round]

    [(patch :flute)
     (fill> (/ 1 (* 6 64))
            (maybe
             (any-that* (within-pitch-bounds? :G-1 :C2)
                        [d4- d3- d1- d1 d3 d4])))
     (each (probs {void 1
                   same 5}))
     m/connect-repetitions
     (vel-humanize 10 [30 70])]))

  (adjust 48))
#+end_src

*** Cyclic episode (Sam Rivers)
One more shredding experiment

#+begin_src clojure :pp
(def CYCLIC_EPISODE
  (let [a1 [dorian (rep 4 (transpose c3))]
        a2 [dorian (rep 4 (transpose c3-))]
        b (lin [IV dorian] [V superlocrian (structure [2 3 5 6])])
        c (lin [V mixolydian sus47] [V phrygian sus27])
        d [dorian (append (transpose c3))]]
    [tetrad
     (tup [(root :Bb) a1]
          [(root :G) b] [(root :D) b]
          [(root :D) a2]
          [(root :G) c] [(root :Eb) d])
     (dupt 4)
     (h/align-contexts :s :static)]))

(let [n-bars (* 4 16)

      bass [(patch :acoustic-bass) (each t2-)]
      vibe [(patch :vibraphone) vel5 t1 (each (par s0 s1 s2 s3)) h/voice-led]

      ;; alternate leads

      lead1 (ntup> (* n-bars 12)
                   (any-that (within-pitch-bounds? :C0 :C3)
                             d1 d1- d3 d3- d4 d4-))

      lead2 [(repeat-while (within-time-bounds? 0 (* n-bars 10))
               (append [start-from-last
                        (any-that (within-pitch-bounds? :C-1 :C2)
                                  (rep 3 d3 :skip-first)
                                  (rep 3 d3- :skip-first)
                                  d1 d1-)]))
             (adjust 1)]

      lead4 [(tup (mixtup s0 s1 s2 s3)
                  (mixtup s2 s3 s4 s5))
             (rup n-bars
                  (probs {(m/permutation [0 1/2]) 2
                          (m/rotation :rand) 3
                          rev 1
                          (any-that* (within-pitch-bounds? :C0 :C3)
                                     (map s-step (range -2 3))) 5}))]]

  (play CYCLIC_EPISODE
        (chans bass
               vibe
               [(h/grid-zipped lead4)
                (chans [(patch :flute) vel8 s2]
                       [(patch :electric-piano-1) vel5])
                (each (probs {vel0 1
                           same 2}))])
        (vel-humanize 0.15)
        (adjust 64)))
#+end_src

*** Inner urge (Joe Henderson)


#+begin_src clojure
(defn last-n-positions
           "Limit the score to the n latest positions found."
           [n]
           (sf_ (let [_ (->> (group-by :position _)
                             seq (sort-by key)
                             reverse (take n)
                             (map second) (reduce into #{}))]
                  (update-score _ (start-from (score-origin _))))))

(let [n-bars 24
      choir [(patch :choir-aahs) vel5 (par> d3 d3 d3)]
      bass [(patch :acoustic-bass) C-2 t-round]
      lead-line (any-that (within-pitch-bounds? :C0 :C3)
                          (rep 2 d3 :skip-first)
                          (rep 2 d3- :skip-first)
                          d4 d4-
                          d1 d1-
                          (rep 3 d2 :skip-first)
                          (rep 3 d2- :skip-first))]
  (play (h/harmonic-zip
         [(tup (lin (nlin 4 [(root :F#) locrian2])
                    (nlin 4 [(root :F) lydian])
                    (nlin 4 [(root :Eb) lydian])
                    (nlin 4 [(root :Db) lydian]))
               [lydian
                (lin* (map root [:E :Db :D :B :C :A :Bb :G]))])
          (h/align-contexts :s)
          (dupt 4)]
         (tup (chans choir
                     bass
                     [(patch :music-box)
                      vel5 C1
                      (m/simple-tupline (* n-bars 10) lead-line)])
              (chans choir
                     bass
                     [(patch :ocarina)
                      vel4 C1
                      (m/simple-tupline (* n-bars 24) lead-line)])
              (chans choir
                     bass
                     [(patch :sawtooth)
                      (dur (/ 1 n-bars))
                      vel4 C1
                      (tup d0 d3 d6)
                      (tup d0 d4 d8)
                      (m/line (one-of (last-n-positions 10) (last-n-positions 7))
                              (any-that (within-pitch-bounds? :C0 :C3)
                                        (m/permutation {:grade 3})
                                        #_(one-of (m/contour :rotation {:layer :d})
                                                  (m/contour :mirror {:layer :d})
                                                  (m/contour :similar {:delta 0 :layer :d}))
                                        (one-of d1 d1-)
                                        (one-of d2 d2-))
                              (sf_ (> (score-duration _) 1))
                              (trim 0 1))
                      (vel-humanize 5 [40 80])])
              (chans [choir
                      (ntup (/ n-bars 2) same)
                      ($by :position [(! (one-of (r/gen-tup 8 3 :euclidean)
                                                 (r/gen-tup 8 3 :durations [2 3 4 5])))
                                      (sf_ (let [xs (-> (group-by :position _) seq sort vals)]
                                             (reduce into #{} (map update-score xs (pr/shuffle [d0 d1 d1-])))))])]
                     bass)))
        (adjust 180)))

#+end_src


** snippets
*** textures 1

Trying to produce vibrating textures by playing very fast note sequences.

#+begin_src clojure :pp
(play dur2
      lydian
      (patch :flute)
      (chans _ d3 d6 d9)
      (each [(dupt 24) (each (one-of vel1 vel3 vel6)
                       (probs {_ 6 d1 1}))])
      ($by :channel (maybe rev))
      (append (transpose c3-))
      (append (transpose c1-)))
#+end_src


#+begin_src clojure :pp
(play dur3
      lydian
      (chans [(patch :marimba) (lin _ c1)]
             [(patch :vibraphone) (lin d3 d2)]
             [(patch :celesta) (lin d6 d6)]
             [(patch :orchestral-harp) (lin d9 d9)])
      (append (transpose c2-))
      (dup 2)

      (each [(dupt 34)
          (each (one-of vel0 vel3 vel6 vel9)
             (probs {_ 4 o1 1}))]))
#+end_src


#+begin_src clojure :pp
(play dur8
      o2
      (dupt 128)
      (each (par> d4 d4 d4)
         (one-of vel0 vel1 vel2 vel3 vel4 vel5)))
#+end_src

*** Sparkling waves

#+begin_src clojure
(play dur:4
      vel4
      (scale :lydian)
      (patch :music-box)
      (par s0 s2 s4)
      (rep 3 (each [{:mark (rand)} s1 {:velocity (div 1.1) :duration (mul 1.3)} (shuftup s2- s0 s2)])
           :skip-first)
      (lin I [rev III] [o1- V] [rev o1- VII])
      (append [rev (transpose c3)]))
#+end_src

*** infinite climb

#+begin_src clojure
(play dur6 dur2
      (patch :ocarina)
      (rup 36 c1)
      (sf_ (set (map-indexed (fn [i n] (let [vel (* 60 2 (/ (inc i) (count _)))
                                            vel (if (> vel 60) (- 60 (- vel 60)) vel)]
                                        (assoc n :velocity vel)))
                             (sort-by :position _))))
      (par _
           (m/rotation 1/3)
           (m/rotation 2/3))
      (dup 4))
#+end_src

*** violin fast arpegio

#+begin_src clojure
(play (dur 3/2)
      dorian
      (patch :violin)
      (lin I IV V I)
      (h/align-contexts :s)
      (each (ntup 2 (tup s0 s2 s4 s4 s2 s0)))
      (each (! (vel (mul (+ 0.9 (* (rand) 0.2))))))
      (append s1-))
#+end_src

*** zip rythmn

#+begin_src clojure
(play lydianb7
      (h/modal-structure 5)
      (chans
       [(patch :vibraphone)
        (shuflin s0 s1 s2 s3 s4)
        (nlin 4 (one-of s1 s2 s1- s2-))
        (sf_ (let [rythmn (mk (nlin 2 (! (r/gen-tup 12 5 :shifted))) (append rev))]
               (set (map (fn [r n]
                           (merge n (select-keys r [:position :duration])))
                         (sort-by :position rythmn)
                         (sort-by :position _)))))]
       [(patch :woodblock) (r/gen-tup 12 5 :euclidean) (dup 4)]
       [(patch :tinkle-bell) (dup 4)]
       [(patch :metallic) (shuflin s0 s1 s2 s3) (each (par s0 s1 s2))]
       [(patch :acoustic-bass) t2- (dup 4)])
      (adjust 8)
      (append [(transpose c3-) s1 rev] _))
#+end_src

*** Gradual melodic transformation

Random harmonic seq using IV II and VI degrees on vibraphone, ocarina melody derives using transposition, rotation and permutation.

#+begin_src clojure :pp
(play (chans

       [(patch :vibraphone)
        vel3
        (ntup 4 [(one-of IV II VI) tetrad (par [t2- vel5] s0 s1 s2 s3)])]

       [(patch :ocarina)
        vel5
        (shuftup d1 d2 d3 d4 d5)
        (each (maybe (par d0 d3)))
        (rup 16
             (probs {(m/permutation :rand) 1
                     (m/rotation :rand) 3
                     (one-of* (map d-step (range -3 4))) 5}))])

      (adjust 10)
      (append [d2- (transpose c3)]
              [d2 (transpose c3-)]
              same))
#+end_src

*** Bach prelude Cm melodic pattern

#+begin_src clojure
(play harmonic-minor
      (m/$lin (lin I IV I V))
      (h/align-contexts :s)
      (lin _ s1)
      (each (chans (tup s2 [s1 (lin _ d1- _)] s0 [s1 (lin _ d1- _)])
                   (tup s3- [s2- (lin _ d1 _)] s1- [s2- (lin _ d1 _)])))
      (lin _ [(transpose c3) rev])
      (dup 2))
#+end_src


#+begin_src clojure
(play harmonic-minor
      (m/$lin (lin I IV I V))
      (h/align-contexts :s)
      (lin _ s1)
      (let [pat1 (tup s2 [s1 (lin _ d1- _)] s0 [s1 (lin _ d1- _)])
            pat2 [pat1 (m/contour :mirror {:layer :s})]]
        (each (chans [o1 pat1]
                     [s1- pat2]))))
#+end_src


#+begin_src clojure
(play harmonic-minor
      dur2
      (lin _ (transpose c3) _)
      (m/$lin (lin I IV I V))
      (h/align-contexts :s)
      (let [br (lin _ (one-of d1 d1-) _)
            pat1 (one-of (tup s2 [s1 br] s0 [s1 br])
                         (tup [s1 br] s2 [s1 br] s0)
                         (tup s0 [s1 br] s2 [s1 br])
                         (tup [s1 br] s0 [s1 br] s2))
            pat2 (one-of (tup s3- [s2- br] s1- [s2- br])
                         (tup s1- [s2- br] s3- [s2- br]))]
        (each (chans [o1 (patch :ocarina) vel8 pat1]
                     [(patch :vibraphone) pat2])))
      (dup 2))
#+end_src

*** Modal chords

#+begin_src clojure
(let [rand-color (fn []
                   (let [k (rand-nth [:lydian+ :lydian :ionian :dorian
                                      :melodic-minor :mixolydian :phrygian6])]
                     [(scale k)
                      (h/modal-structure 4)]))]
  (play dur2
        (lin* (map (comp transpose c-step) (shuffle (range 12))))
        (each (! (rand-color)))
        (h/align-contexts :d :static)
        (chans [(patch :aahs) (each (par s0 s2 s3 s5)) #_h/voice-led]
               [(patch :vibraphone) o1 (each (par s0 s2 s3) (shuftup s0 s3) (tup s0 s1 s1-))
                ($by :position (probs {vel0 2
                                       (one-of vel3 vel5 vel7) 8
                                       [vel3 (ntup> 4 [s1 (vel+ 15)])] 1}))]
               [(patch :acoustic-bass) o1- t-round])))


#+end_src


#+begin_src clojure
(defn possible-modes
  "given a chromatic degree (int between 0 an 11)
            return possible modes"
  [cd modal-lvl least-priority]
  (let [modes (nc/lvl->mode->degree-priority modal-lvl)
        candidates (filter (fn [[_ s]] (-> (take least-priority s)
                                          (set) (contains? cd)))
                           modes)]
    candidates))

(play (patch :aahs)
      dur4
      (shuflin c0 c1 c2 c3)
      (m/contour :similar {:delta 4 :layer :c})
      (par o1 [c6- (m/contour :mirror {:layer :c})])
      ($by :position
           (sfn score
                (let [modal-lvl 1
                      chord-size 4
                      [min-pitch-val max-pitch-val] (h/pitch-values score)
                      interval (mod (- max-pitch-val min-pitch-val) 12)
                      [mode-kw prio] (rand-nth (possible-modes interval modal-lvl (dec chord-size)))
                      partial-scale (cons 0 (take (dec chord-size) prio))
                      structure' (nc/partial-scale->structure mode-kw partial-scale)
                      closed (mk (dissoc (first score) :pitch)
                                 (origin min-pitch-val)
                                 (scale mode-kw)
                                 (structure structure')
                                 (par* (map s-step (range chord-size))))
                      drops (filter (fn [drop] (= max-pitch-val (last (h/pitch-values drop))))
                                    (h/drops closed))]
                  (rand-nth drops))))
      ($by :position (chans _
                            [(patch :contrabass) vel3 min-pitch o1-]
                            [max-pitch
                             (patch :ocarina)
                             (mixtup s0 s1- s2- s3- s4- s5-)
                             (tup _ s2- s1)
                             #_(each (probs {_ 4 (tup _ [vel4 (maybe s2- s3-)]) 1}))]))
      (lin _ [rev c3])
      (lin _ [rev c3-])
      (options :bpm 30 :xml true :preview true))
#+end_src

*** melodic development

#+begin_src clojure
(play

  ;; use dorian mode
  dorian

  ;; random tup holding the 7 degrees of the scale
  (shuftup d0 d1 d2 d3 d4 d5 d6)

  ;; iterating while within time span 0-8
  (repeat-while (within-time-bounds? 0 8)
                ;; each time we will append to the current score
                (append
                 ;; taking care to stay within pitch bounds
                 (any-that (within-pitch-bounds? :C0 :C3)
                           ;; those 4 expression are randomly picked (if they respect the pitch bound condition)
                           ;; each one is operating on the nth last elements of the melody using the
                           ;; `noon.score/start-from-nth-last` update builder.
                           [(start-from-nth-last 1) (one-of d1- d1)]
                           ;; takes a random permutation in the 0-1/4 complexity range
                           [(start-from-nth-last 8) (m/permutation [0 1/4])]
                           ;; reverse the 4 last four notes of the score
                           [(start-from-nth-last 4) rev]
                           ;; change the contour of the last four notes
                           [(start-from-nth-last 4) (m/contour :similar {:extent [-2 2] :layer :d})]))
                ;; at the end of the loop we adjust the score duration
                (trim 0 8))

  ;; each note will have some chance to spawn some extra voice (vibraphone or flute)
  ;; or a velocity humanisation
  (each
   (probs {(one-of vel3 vel5 vel7 vel9) 6
           (superpose [(chan 2) (patch :vibraphone) vel8 (one-of d3 d4)]) 1
           (superpose [(chan 7) (patch :flute) vel8 o1]) 5
           }))

  ;; adding a simple bass
  (superpose (k (nlin 4 [(chan 5) (patch :acoustic-bass) t2- vel8 dur2])))

  ;; a randomized harmonic modulation sequence
  (rep 4 (one-of [(d-shift -2) (transpose c3)]
                 [(d-shift 2) (transpose c3-)]
                 [(d-shift 1) (transpose c1-)]
                 [(d-shift -3) (transpose c6)]))

  ;; the whole score is repeated superposing a taiko drum
  (append (superpose (k (nlin 4 [(patch :taiko-drum) (chan 3) (! [vel4 (maybe o1- d1) (r/gen-tup 7 3)])])
                        (dup 8)))))
#+end_src

** Usage
*** =noon.lib.rythmn/bintup=

An experiment around =noon.lib.rythmn/gen-bintup=
The =gen-bintup= function is used to produce a bass line and a fast rythmic texture alternating between electric-piano and marimba.

#+begin_src clojure
(play dur6
      (lin [I dorian]
           [III mixolydian]
           [VIb lydian]
           [I lydian])
      (append> (transpose c1-) (transpose c1-) (transpose c1-))
      (dup 2)
      (h/align-contexts)
      (each (chans [(patch :new-age) vel3  o1- (par s0 s1 s2 s3 [o1 (par> d3 d3 d3 d3)])]
                   [(patch :taiko-drum) (r/gen-tup 9 3 :durations [2 3 4]) (each (one-of vel4 vel3) (maybe d3 d3-))]
                   [(patch :acoustic-bass)
                    t-floor o1-
                    (r/gen-bintup 9 4 :euclidean :shifted)
                    vel4 (vel-humanize 1/5)
                    (parts {:bintup 0} (each (vel+ 20) (one-of s0 s1))
                           {:bintup 1} (each (probs {vel0 2 (one-of d3- d4) 1})))]
                   [(r/gen-bintup 54 11  :shifted :euclidean)
                    (parts {:bintup 0} [(patch :electric-piano-1)
                                        sus4
                                        (each vel3
                                              (vel-humanize 1/10)
                                              (one-of d2 d4 d6)
                                              (probs {_ 3 [(one-of s0 s1 s2) (par s0 s1 s2)] 1}))]
                           {:bintup 1} [(patch :marimba)
                                        vel4
                                        (vel-humanize 1/5)
                                        (chan+ 1)
                                        (each [(one-of d3 d5 d7) (maybe o1 (par _ d4))])])])))
#+end_src

*** =noon.lib.harmony/grid=

#+begin_src clojure
(play dur3
      (nlin> 48 (one-of d1 d1-))
      (each (chans [(patch :aahs) vel5 (par s0 s1 s2 s3)]
                   [(patch :ocarina) (shuftup s0 s2 s4 s6) (shuftup d0 d3 d6) (tup _ rev)]
                   [(patch :acoustic-bass) t2-]))
      (h/grid dur3 tetrad
              (lin [I lydian (structure [2 3 5 6])]
                   [IIb dorian (structure [1 2 3 6])]
                   [V mixolydian (structure [2 3 5 6])]
                   [Vb melodic-minor (structure [1 2 5 6])])
              (rep 6 (transpose c2-))
              (dup 2)
              (h/align-contexts :d :static)))
#+end_src

#+begin_src clojure
(play (ntup> 24 (one-of d1 d1-))
      (each (chans [(patch :aahs) vel5 (par s0 s1 s2 s3)]
                   [(patch :ocarina)
                    (one-of (mixtup s0 s2 s4 s6)
                            (mixtup s0 s2 s4 s6))
                    (one-of (mixtup d0 d3 d6)
                            (mixtup d0 d3 d6))
                    (vel-humanize 10 [40 80])
                    (tup _ rev)]
                   [(patch :acoustic-bass) t2-]))
      (h/grid tetrad
              (tup [I lydian]
                   [IIb dorian]
                   [V mixolydian]
                   [Vb melodic-minor])
              (each (h/modal-structure 4))
              (rup 4 (transpose c2-))
              (dupt 2)
              (h/align-contexts :d :static))
      (adjust 60))
#+end_src

#+begin_src clojure
(play (chans [(patch :aahs) vel5 (par s0 s1 s2 s3)]
             [(patch :acoustic-bass) t2-])
      (h/grid (lin [I lydian (structure [2 3 5 6])]
                   [IIb dorian (structure [1 2 3 6])]
                   [V mixolydian (structure [2 3 5 6])]
                   [Vb melodic-minor (structure [1 2 5 6])])
              (rep 2 (transpose c2-))
              (dup 2)
              (h/align-contexts :d :static)
              (adjust 1))
      (parts (patch :acoustic-bass)
             (each (tup (maybe o1) (one-of d4 d3-))))
      (adjust 32))
#+end_src

#+begin_src clojure
(play (chans [(patch :aahs)
              vel6
              (rup 24 (any-that (within-pitch-bounds? :G-1 :G1)
                                s2 s2- s3 s3-))
              (each (par s0 s1 s2 s3))]
             [(patch :acoustic-bass) t2-])
      (h/grid tetrad
              (lin [I lydian (structure [2 3 5 6])]
                   [IIb dorian (structure [1 2 3 6])]
                   [V mixolydian (structure [2 3 5 6])]
                   [Vb melodic-minor (structure [1 2 5 6])])
              (rep 2 (transpose c2-))
              (dup 2)
              (h/align-contexts :d :static)
              (adjust 1))
      (parts (patch :acoustic-bass)
             (each (tup (maybe o1) (one-of d4 d3-))))
      (adjust 32))
#+end_src

#+begin_src clojure
(play (rup 128 (any-that (within-pitch-bounds? :C1 :C3)
                         s1 s2 s3 s1- s2- s3-))
      (chans (each (probs {_ 2
                           vel0 1
                           (shuftup s1- s0 s1 s2) 1}))
             (each s1- (probs {_ 2
                               vel0 1
                               (shuftup s1- s0 s1) 1}))
             (each [s2- o1- (probs {_ 2
                                    (shuftup s0 s2) 1})]))
      (h/grid harmonic-minor
              (tup I IV VII I [IV melodic-minor VII] IV [V harmonic-minor VII] VII)
              (dupt 4)
              (h/align-contexts :s))
      (adjust {:duration 64}))
#+end_src

*** Vienna symphonic library

Using the awesome Vienna Symphonic Library for playback.
The Vienna Ensemble setup file is provided =vsl/setup1.vep64=
It assumes VSL special edition (volumes 1+ and 2+)

#+begin_src clojure
(vsl/noon {:play true}
          (mk (par [(vsl :chamber-violins-1 :detache)
                    (lin s0
                         [(vsl/patch :legato) (tup s1 s2 s3)]
                         [(vsl/patch :pizzicato)
                          (par [(vsl/patch :snap-pizzicato) _]
                               [(vsl :solo-double-bass :pizzicato) o2- (tup s2 s1)])])]
                   [(vsl :flute-1 :portato) o1 s- (lin s0 [(vsl/patch :legato) (tup s1 s2 s3)])])
              (lin s0 s2 s1-)
              (dup 4)))

(vsl/noon {:play true}
          (mk vel10
              (vsl/instrument :chamber-cellos)
              (vsl/patch :pizzicato)
              o1-
              (shuftup d0 d3 d6)
              (shuftup d0 d3 d6)
              (dup 8)))
#+end_src
