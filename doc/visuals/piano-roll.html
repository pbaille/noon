<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #fff; font-family: -apple-system, 'Helvetica Neue', sans-serif; }
  #root { display: inline-block; padding: 20px; }

  .image-block { margin-bottom: 32px; }
  .image-title {
    font-size: 13px; font-weight: 600; color: #333;
    margin-bottom: 6px;
    font-family: 'SF Mono', 'Fira Code', 'Menlo', monospace;
  }
  .legend {
    display: flex; gap: 14px; margin-bottom: 10px;
    font-size: 10.5px; color: #555;
  }
  .legend-item { display: flex; align-items: center; gap: 4px; }
  .legend-swatch { width: 10px; height: 10px; border-radius: 2px; }

  .group { display: flex; flex-direction: column; gap: 6px; }
  .group-row { display: flex; align-items: flex-start; gap: 0; }
  .group-label {
    font-size: 11px; font-weight: 500; color: #444;
    font-family: 'SF Mono', 'Fira Code', 'Menlo', monospace;
    margin-bottom: 2px;
  }
  .group-separator { height: 1px; background: #e5e7eb; margin: 4px 0; }
</style>
</head>
<body>
<div id="root"></div>

<script>
// ── Colors ──
const COLORS = {
  tonic:      { fill: '#1a56db', stroke: '#1446b3', label: 'Tonic' },
  structural: { fill: '#3b82f6', stroke: '#2563eb', label: 'Structural' },
  diatonic:   { fill: '#93c5fd', stroke: '#60a5fa', label: 'Diatonic' },
  chromatic:  { fill: '#d1d5db', stroke: '#9ca3af', label: 'Chromatic' },
};
const HARMONY_COLOR = 'rgba(99, 102, 241, 0.06)';
const HARMONY_BORDER = 'rgba(99, 102, 241, 0.25)';

// ── Helpers ──
const NOTE_NAMES = ['C','C♯','D','D♯','E','F','F♯','G','G♯','A','A♯','B'];
function isBlackKey(midi) { return [1,3,6,8,10].includes(midi % 12); }
function noteName(midi) { return NOTE_NAMES[midi % 12] + (Math.floor(midi / 12) - 1); }

const ns = 'http://www.w3.org/2000/svg';
function el(tag, attrs) {
  const e = document.createElementNS(ns, tag);
  for (const [k, v] of Object.entries(attrs)) e.setAttribute(k, v);
  return e;
}

// ── Build one piano roll SVG ──
function buildRoll(notes, harmonies, { minPitch, maxPitch, timeScale, showKeyboard = true, showHarmonies = true }) {
  const ROW_H = 18;
  const KB_W = showKeyboard ? 44 : 0;
  const maxTime = Math.max(...notes.map(n => n.position + n.duration));
  const GRID_W = Math.max(Math.ceil(maxTime * timeScale), 60);
  const nRows = maxPitch - minPitch;
  const GRID_H = nRows * ROW_H;
  const W = KB_W + GRID_W + 1;
  const H = GRID_H + 1;

  const svg = document.createElementNS(ns, 'svg');
  svg.setAttribute('width', W);
  svg.setAttribute('height', H);
  svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
  svg.style.display = 'block';

  function pitchY(p) { return (maxPitch - p - 1) * ROW_H; }

  // Grid rows
  for (let p = minPitch; p < maxPitch; p++) {
    const y = pitchY(p);
    svg.appendChild(el('rect', {
      x: KB_W, y, width: GRID_W, height: ROW_H,
      fill: isBlackKey(p) ? '#f5f5f5' : '#fff',
    }));
    svg.appendChild(el('line', {
      x1: KB_W, y1: y + ROW_H, x2: W, y2: y + ROW_H,
      stroke: p % 12 === 11 ? '#d4d4d4' : '#eeeeee', 'stroke-width': 0.5,
    }));
  }

  // Harmony boundaries
  if (showHarmonies && harmonies && harmonies.length > 1) {
    for (let i = 0; i < harmonies.length; i++) {
      const h = harmonies[i];
      const x = KB_W + h.position * timeScale;
      const w = h.duration * timeScale;
      // Alternating subtle background
      if (i % 2 === 1) {
        svg.appendChild(el('rect', {
          x, y: 0, width: w, height: GRID_H,
          fill: HARMONY_COLOR,
        }));
      }
      // Vertical boundary line (skip first)
      if (i > 0) {
        svg.appendChild(el('line', {
          x1: x, y1: 0, x2: x, y2: GRID_H,
          stroke: HARMONY_BORDER, 'stroke-width': 1,
          'stroke-dasharray': '4,3',
        }));
      }
    }
  }

  // Grid border
  svg.appendChild(el('rect', {
    x: KB_W, y: 0, width: GRID_W, height: GRID_H,
    fill: 'none', stroke: '#ddd', 'stroke-width': 1,
  }));

  // Piano keyboard
  if (showKeyboard) {
    for (let p = minPitch; p < maxPitch; p++) {
      const y = pitchY(p);
      const black = isBlackKey(p);
      svg.appendChild(el('rect', {
        x: 0, y, width: KB_W, height: ROW_H,
        fill: black ? '#374151' : '#f9fafb',
        stroke: '#d1d5db', 'stroke-width': 0.5,
      }));
      if (p % 12 === 0 || p === minPitch) {
        const text = document.createElementNS(ns, 'text');
        text.setAttribute('x', KB_W - 5);
        text.setAttribute('y', y + ROW_H / 2 + 3.5);
        text.setAttribute('text-anchor', 'end');
        text.setAttribute('font-size', '8.5');
        text.setAttribute('font-family', "'SF Mono', 'Fira Code', monospace");
        text.setAttribute('fill', black ? '#e5e7eb' : '#6b7280');
        text.textContent = noteName(p);
        svg.appendChild(text);
      }
    }
  }

  // Notes
  const PAD = 1.5;
  for (const note of notes) {
    const x = KB_W + note.position * timeScale;
    const y = pitchY(note.pitch) + PAD;
    const w = Math.max(note.duration * timeScale - 1, 3);
    const h = ROW_H - PAD * 2;
    const color = COLORS[note.kind] || COLORS.chromatic;

    svg.appendChild(el('rect', {
      x, y, width: w, height: h,
      rx: 2.5, ry: 2.5,
      fill: color.fill, stroke: color.stroke,
      'stroke-width': 0.75, opacity: 0.92,
    }));

    if (w > 24) {
      const text = document.createElementNS(ns, 'text');
      text.setAttribute('x', x + w / 2);
      text.setAttribute('y', y + h / 2 + 3);
      text.setAttribute('text-anchor', 'middle');
      text.setAttribute('font-size', '8');
      text.setAttribute('font-family', "'SF Mono', 'Fira Code', monospace");
      text.setAttribute('fill', ['tonic', 'structural'].includes(note.kind) ? '#fff' : '#475569');
      text.setAttribute('font-weight', '500');
      text.textContent = NOTE_NAMES[note.pitch % 12];
      svg.appendChild(text);
    }
  }

  return svg;
}

// ── Legend ──
function buildLegend(kinds) {
  const order = ['tonic', 'structural', 'diatonic', 'chromatic'];
  kinds.sort((a, b) => order.indexOf(a) - order.indexOf(b));
  const div = document.createElement('div');
  div.className = 'legend';
  for (const kind of kinds) {
    const item = document.createElement('div');
    item.className = 'legend-item';
    const swatch = document.createElement('div');
    swatch.className = 'legend-swatch';
    swatch.style.background = COLORS[kind].fill;
    const label = document.createElement('span');
    label.textContent = COLORS[kind].label;
    item.appendChild(swatch);
    item.appendChild(label);
    div.appendChild(item);
  }
  return div;
}

// ── Compute shared pitch range ──
function pitchBounds(allNotes, padding = 1) {
  const pitches = allNotes.map(n => n.pitch);
  return {
    min: Math.min(...pitches) - padding,
    max: Math.max(...pitches) + padding + 1,
  };
}

// ── Compute adaptive time scale ──
function adaptiveTimeScale(notes, targetWidth = 500) {
  const maxTime = Math.max(...notes.map(n => n.position + n.duration));
  if (maxTime === 0) return 400;
  return Math.min(Math.max(targetWidth / maxTime, 150), 700);
}

// ── Render a "single" image ──
function renderSingle(container, { title, data }) {
  const block = document.createElement('div');
  block.className = 'image-block';

  if (title) {
    const t = document.createElement('div');
    t.className = 'image-title';
    t.textContent = title;
    block.appendChild(t);
  }

  const kinds = [...new Set(data.notes.map(n => n.kind))];
  block.appendChild(buildLegend(kinds));

  const bounds = pitchBounds(data.notes);
  const ts = adaptiveTimeScale(data.notes);
  block.appendChild(buildRoll(data.notes, data.harmonies, {
    minPitch: bounds.min, maxPitch: bounds.max,
    timeScale: ts, showHarmonies: true,
  }));

  container.appendChild(block);
}

// ── Render a "grouped" image ──
function renderGrouped(container, { items, sharedPitchRange }) {
  const block = document.createElement('div');
  block.className = 'image-block';

  const allNotes = items.flatMap(it => it.data.notes);

  // Shared legend
  const kinds = [...new Set(allNotes.map(n => n.kind))];
  block.appendChild(buildLegend(kinds));

  // Shared time scale so widths align visually
  const ts = adaptiveTimeScale(allNotes);

  // Optionally share pitch range (good for scale comparisons)
  const sharedBounds = sharedPitchRange ? pitchBounds(allNotes) : null;

  const group = document.createElement('div');
  group.className = 'group';

  items.forEach((item, i) => {
    if (i > 0) {
      const sep = document.createElement('div');
      sep.className = 'group-separator';
      group.appendChild(sep);
    }

    const label = document.createElement('div');
    label.className = 'group-label';
    label.textContent = item.label;
    group.appendChild(label);

    const bounds = sharedBounds || pitchBounds(item.data.notes);
    group.appendChild(buildRoll(item.data.notes, item.data.harmonies, {
      minPitch: bounds.min, maxPitch: bounds.max,
      timeScale: ts, showKeyboard: true, showHarmonies: true,
    }));
  });

  block.appendChild(group);
  container.appendChild(block);
}

// ── Main ──
function init() {
  if (!window.VISUAL_DATA) return;
  const root = document.getElementById('root');

  // Render in specific order
  const order = window.VISUAL_ORDER || Object.keys(window.VISUAL_DATA);
  for (const key of order) {
    const img = window.VISUAL_DATA[key];
    if (!img) continue;

    // Section ID for screenshot targeting
    const section = document.createElement('div');
    section.id = 'visual-' + key;
    root.appendChild(section);

    if (img.type === 'grouped') {
      renderGrouped(section, img);
    } else {
      renderSingle(section, img);
    }
  }
}

init();
</script>
</body>
</html>
