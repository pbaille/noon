* noon.eval

The =noon.eval= namespace leverages the excellent =babashka.sci= library to integrate various Noon components into a user-friendly interface. More specifically, using top forms in =noon.eval= is akin to being in a namespace with these requirements.

#+begin_src clojure
(ns my.namespace
  (:require [noon.updates :refer :all]
            [noon.events :as events :refer [ef_ efn]]
            [noon.score :as score :refer [score sf_ sfn e->s]]
            [noon.output :as out :refer [noon play]]
            [noon.lib.harmony :as h]
            [noon.lib.melody :as m]
            [noon.lib.rythmn :as r]
            [noon.numbers :refer [mul div add sub]]
            [noon.output.midi :as midi]
            [noon.utils.misc :as u]
            [noon.constants :as constants]
            [noon.utils.pseudo-random :as rand]
            ...
            ))
#+end_src

It also supports the ClojureScript side of things where some restrictions arise. The =:refer :all= syntax is not available in ClojureScript, and the =noon.updates= namespace contains many vars that you might not want to explicitly refer to or prefix.

The three main forms that =noon.eval= exposes (=score=, =play=, =noon=) are macros, primarily for this reason. Beneath this syntactic convenience, the Noon API mainly consists of functions for handling data. The two principal underlying forms (=noon.output/noon=, =noon.score/score=) are functions, and you can achieve anything you need using them directly.
Under this syntactic convenience, the noon API consists mainly of functions dealing with data, the two main underlying forms (=noon.output/noon=, =noon.score/score=) are functions and you can do everything you want using them directly.
